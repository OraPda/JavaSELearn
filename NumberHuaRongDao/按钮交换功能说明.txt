# 数字华容道中点击按钮进行交换功能的实现说明

## 一、功能概述

数字华容道游戏中，点击按钮进行交换是核心功能之一。其基本原理是：
- 游戏中有一个空白位置（通常用0表示）
- 玩家可以点击与空白位置相邻的数字按钮
- 点击后，数字按钮会与空白位置交换位置
- 通过不断交换，最终将数字按顺序排列完成游戏

## 二、实现步骤

### 1. 管理空白位置

首先需要记录空白位置的坐标，这是实现交换功能的基础：

```java
// 在MainFrame类中添加成员变量来记录空白位置
private int emptyRow; // 空白位置的行坐标
private int emptyCol; // 空白位置的列坐标
```

在初始化数字数组时，同时记录空白位置：

```java
// 初始化数字
for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
        if (i == 3 && j == 3) {
            numbers[i][j] = 0; // 最后一个位置设置为空白
            emptyRow = i; // 记录空白位置的行
            emptyCol = j; // 记录空白位置的列
        } else {
            numbers[i][j] = i * 4 + j + 1;
        }
    }
}
```

### 2. 处理按钮点击事件

实现`actionPerformed`方法来处理按钮点击事件：

```java
@Override
public void actionPerformed(ActionEvent e) {
    // 遍历所有按钮，找到被点击的按钮
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (e.getSource() == buttons[i][j]) {
                // 检查点击的按钮是否与空白位置相邻
                if (isAdjacent(i, j)) {
                    // 交换位置
                    swap(i, j, emptyRow, emptyCol);
                    // 更新空白位置
                    emptyRow = i;
                    emptyCol = j;
                    // 更新按钮显示
                    updateButtons();
                    // 检查是否获胜
                    if (checkWin()) {
                        JOptionPane.showMessageDialog(this, "恭喜你，完成了数字华容道！");
                    }
                }
                return;
            }
        }
    }
}
```

### 3. 判断相邻性

实现`isAdjacent`方法来判断点击的按钮是否与空白位置相邻：

```java
// 判断点击的位置是否与空白位置相邻
private boolean isAdjacent(int row, int col) {
    // 相邻的条件：行相同且列相差1，或列相同且行相差1
    return (Math.abs(row - emptyRow) == 1 && col == emptyCol) || 
           (Math.abs(col - emptyCol) == 1 && row == emptyRow);
}
```

### 4. 交换位置

实现`swap`方法来交换两个位置的数字：

```java
// 交换两个位置的数字
private void swap(int row1, int col1, int row2, int col2) {
    int temp = numbers[row1][col1];
    numbers[row1][col1] = numbers[row2][col2];
    numbers[row2][col2] = temp;
}
```

### 5. 更新界面显示

交换数字后，需要更新按钮的显示：

```java
// 更新按钮显示
private void updateButtons() {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (numbers[i][j] == 0) {
                buttons[i][j].setText(""); // 空白位置不显示数字
            } else {
                buttons[i][j].setText(String.valueOf(numbers[i][j]));
            }
            // 更新按钮颜色
            buttons[i][j].setBackground(getButtonColor(numbers[i][j]));
            // 更新文字颜色
            buttons[i][j].setForeground((numbers[i][j] == 5 || numbers[i][j] == 8 || numbers[i][j] == 10 || numbers[i][j] == 11) ? Color.BLACK : Color.WHITE);
        }
    }
}
```

### 6. 检查获胜条件

交换后，检查是否完成游戏：

```java
// 检查是否获胜
private boolean checkWin() {
    int expected = 1;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (i == 3 && j == 3) {
                // 最后一个位置应该是空白
                if (numbers[i][j] != 0) return false;
            } else {
                // 其他位置应该按顺序排列
                if (numbers[i][j] != expected++) return false;
            }
        }
    }
    return true;
}
```

## 三、完整实现示例

将以上所有部分整合到MainFrame类中，完整的按钮交换功能实现如下：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class MainFrame extends JFrame implements ActionListener {
    private int[][] numbers = new int[4][4];
    private JButton[][] buttons = new JButton[4][4];
    private int emptyRow; // 空白位置的行坐标
    private int emptyCol; // 空白位置的列坐标

    public MainFrame() {
        initFrame();
    }

    private void initFrame() {
        setTitle("数字华容道");
        setSize(400, 450);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        JPanel gamePanel = new JPanel(new GridLayout(4, 4));

        // 初始化数字和空白位置
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == 3 && j == 3) {
                    numbers[i][j] = 0;
                    emptyRow = i;
                    emptyCol = j;
                } else {
                    numbers[i][j] = i * 4 + j + 1;
                }
            }
        }

        // 创建按钮
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                buttons[i][j] = new JButton();
                buttons[i][j].setFont(new Font("Arial", Font.BOLD, 20));
                buttons[i][j].addActionListener(this);
                gamePanel.add(buttons[i][j]);
            }
        }

        add(gamePanel);
        updateButtons();
    }

    private Color getButtonColor(int number) {
        Color[] colors = {
                new Color(189, 195, 199), // 空白
                new Color(255, 107, 107), // 1
                new Color(78, 205, 196),  // 2
                new Color(69, 183, 209),  // 3
                new Color(150, 206, 180), // 4
                new Color(255, 234, 167), // 5
                new Color(221, 160, 221), // 6
                new Color(152, 216, 200), // 7
                new Color(247, 220, 111),  // 8
                new Color(243, 163, 255),   // 9
                new Color(48, 56, 255),  // 10
                new Color(75, 64, 255),   // 11
                new Color(68, 255, 255),   // 12
                new Color(69, 255, 84),   // 13
                new Color(91, 42, 160),   // 14
                new Color(13, 16, 79),   // 15
        };
        return colors[number];
    }

    // 更新按钮显示
    private void updateButtons() {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (numbers[i][j] == 0) {
                    buttons[i][j].setText("");
                } else {
                    buttons[i][j].setText(String.valueOf(numbers[i][j]));
                }
                buttons[i][j].setBackground(getButtonColor(numbers[i][j]));
                buttons[i][j].setForeground((numbers[i][j] == 5 || numbers[i][j] == 8 || numbers[i][j] == 10 || numbers[i][j] == 11) ? Color.BLACK : Color.WHITE);
                buttons[i][j].setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
            }
        }
    }

    // 判断点击的位置是否与空白位置相邻
    private boolean isAdjacent(int row, int col) {
        return (Math.abs(row - emptyRow) == 1 && col == emptyCol) || 
               (Math.abs(col - emptyCol) == 1 && row == emptyRow);
    }

    // 交换两个位置的数字
    private void swap(int row1, int col1, int row2, int col2) {
        int temp = numbers[row1][col1];
        numbers[row1][col1] = numbers[row2][col2];
        numbers[row2][col2] = temp;
    }

    // 检查是否获胜
    private boolean checkWin() {
        int expected = 1;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == 3 && j == 3) {
                    if (numbers[i][j] != 0) return false;
                } else {
                    if (numbers[i][j] != expected++) return false;
                }
            }
        }
        return true;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        // 遍历所有按钮，找到被点击的按钮
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (e.getSource() == buttons[i][j]) {
                    // 检查点击的按钮是否与空白位置相邻
                    if (isAdjacent(i, j)) {
                        // 交换位置
                        swap(i, j, emptyRow, emptyCol);
                        // 更新空白位置
                        emptyRow = i;
                        emptyCol = j;
                        // 更新按钮显示
                        updateButtons();
                        // 检查是否获胜
                        if (checkWin()) {
                            JOptionPane.showMessageDialog(this, "恭喜你，完成了数字华容道！");
                        }
                    }
                    return;
                }
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            MainFrame frame = new MainFrame();
            frame.setVisible(true);
        });
    }
}
```

## 四、功能流程总结

1. **初始化阶段**：创建4x4的数字数组和按钮数组，将最后一个位置设为空白，并记录空白位置的坐标。

2. **按钮点击事件**：当用户点击某个按钮时，触发`actionPerformed`方法。

3. **相邻性检查**：判断点击的按钮是否与空白位置相邻（行相同且列相差1，或列相同且行相差1）。

4. **位置交换**：如果点击的按钮与空白位置相邻，则交换它们的数字。

5. **更新空白位置**：将空白位置的坐标更新为点击按钮的位置。

6. **界面更新**：更新按钮的显示，包括数字、颜色等。

7. **获胜检查**：检查数字是否按顺序排列，如果是，则显示获胜提示。

## 五、注意事项

1. **边界检查**：确保点击的位置不会超出数组范围（在本实现中，通过遍历4x4的按钮数组已经隐含了边界检查）。

2. **性能优化**：由于数字华容道的规模较小（通常是3x3或4x4），所以不需要复杂的性能优化。

3. **用户体验**：可以添加动画效果来增强用户体验，例如按钮交换时的平滑过渡。

4. **可扩展性**：可以通过调整数组的大小来支持不同规模的数字华容道（如5x5）。

通过以上实现，就可以完成数字华容道中点击按钮进行交换的核心功能。